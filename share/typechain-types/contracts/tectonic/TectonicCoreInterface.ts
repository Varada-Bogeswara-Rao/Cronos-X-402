/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface TectonicCoreInterfaceInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "borrowAllowed"
      | "borrowVerify"
      | "enterMarkets"
      | "exitMarket"
      | "isTectonicCore"
      | "liquidateBorrowAllowed"
      | "liquidateBorrowVerify"
      | "liquidateCalculateSeizeTokens"
      | "mintAllowed"
      | "mintVerify"
      | "redeemAllowed"
      | "redeemVerify"
      | "repayBorrowAllowed"
      | "repayBorrowVerify"
      | "seizeAllowed"
      | "seizeVerify"
      | "transferAllowed"
      | "transferVerify"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "borrowAllowed",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowVerify",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "enterMarkets",
    values: [AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "exitMarket",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isTectonicCore",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateBorrowAllowed",
    values: [AddressLike, AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateBorrowVerify",
    values: [
      AddressLike,
      AddressLike,
      AddressLike,
      AddressLike,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateCalculateSeizeTokens",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mintAllowed",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mintVerify",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemAllowed",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemVerify",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "repayBorrowAllowed",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "repayBorrowVerify",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "seizeAllowed",
    values: [AddressLike, AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "seizeVerify",
    values: [AddressLike, AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAllowed",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferVerify",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "borrowAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "borrowVerify",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enterMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "exitMarket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isTectonicCore",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidateBorrowAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidateBorrowVerify",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidateCalculateSeizeTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mintVerify", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redeemAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemVerify",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "repayBorrowAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "repayBorrowVerify",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "seizeAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "seizeVerify",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferVerify",
    data: BytesLike
  ): Result;
}

export interface TectonicCoreInterface extends BaseContract {
  connect(runner?: ContractRunner | null): TectonicCoreInterface;
  waitForDeployment(): Promise<this>;

  interface: TectonicCoreInterfaceInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  borrowAllowed: TypedContractMethod<
    [tToken: AddressLike, borrower: AddressLike, borrowAmount: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  borrowVerify: TypedContractMethod<
    [tToken: AddressLike, borrower: AddressLike, borrowAmount: BigNumberish],
    [void],
    "nonpayable"
  >;

  enterMarkets: TypedContractMethod<
    [tTokens: AddressLike[]],
    [bigint[]],
    "nonpayable"
  >;

  exitMarket: TypedContractMethod<
    [tToken: AddressLike],
    [bigint],
    "nonpayable"
  >;

  isTectonicCore: TypedContractMethod<[], [boolean], "view">;

  liquidateBorrowAllowed: TypedContractMethod<
    [
      tTokenBorrowed: AddressLike,
      tTokenCollateral: AddressLike,
      liquidator: AddressLike,
      borrower: AddressLike,
      repayAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  liquidateBorrowVerify: TypedContractMethod<
    [
      tTokenBorrowed: AddressLike,
      tTokenCollateral: AddressLike,
      liquidator: AddressLike,
      borrower: AddressLike,
      repayAmount: BigNumberish,
      seizeTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  liquidateCalculateSeizeTokens: TypedContractMethod<
    [
      tTokenBorrowed: AddressLike,
      tTokenCollateral: AddressLike,
      repayAmount: BigNumberish
    ],
    [[bigint, bigint]],
    "view"
  >;

  mintAllowed: TypedContractMethod<
    [tToken: AddressLike, minter: AddressLike, mintAmount: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  mintVerify: TypedContractMethod<
    [
      tToken: AddressLike,
      minter: AddressLike,
      mintAmount: BigNumberish,
      mintTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  redeemAllowed: TypedContractMethod<
    [tToken: AddressLike, redeemer: AddressLike, redeemTokens: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  redeemVerify: TypedContractMethod<
    [
      tToken: AddressLike,
      redeemer: AddressLike,
      redeemAmount: BigNumberish,
      redeemTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  repayBorrowAllowed: TypedContractMethod<
    [
      tToken: AddressLike,
      payer: AddressLike,
      borrower: AddressLike,
      repayAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  repayBorrowVerify: TypedContractMethod<
    [
      tToken: AddressLike,
      payer: AddressLike,
      borrower: AddressLike,
      repayAmount: BigNumberish,
      borrowerIndex: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  seizeAllowed: TypedContractMethod<
    [
      tTokenCollateral: AddressLike,
      tTokenBorrowed: AddressLike,
      liquidator: AddressLike,
      borrower: AddressLike,
      seizeTokens: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  seizeVerify: TypedContractMethod<
    [
      tTokenCollateral: AddressLike,
      tTokenBorrowed: AddressLike,
      liquidator: AddressLike,
      borrower: AddressLike,
      seizeTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  transferAllowed: TypedContractMethod<
    [
      tToken: AddressLike,
      src: AddressLike,
      dst: AddressLike,
      transferTokens: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferVerify: TypedContractMethod<
    [
      tToken: AddressLike,
      src: AddressLike,
      dst: AddressLike,
      transferTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "borrowAllowed"
  ): TypedContractMethod<
    [tToken: AddressLike, borrower: AddressLike, borrowAmount: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "borrowVerify"
  ): TypedContractMethod<
    [tToken: AddressLike, borrower: AddressLike, borrowAmount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "enterMarkets"
  ): TypedContractMethod<[tTokens: AddressLike[]], [bigint[]], "nonpayable">;
  getFunction(
    nameOrSignature: "exitMarket"
  ): TypedContractMethod<[tToken: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "isTectonicCore"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "liquidateBorrowAllowed"
  ): TypedContractMethod<
    [
      tTokenBorrowed: AddressLike,
      tTokenCollateral: AddressLike,
      liquidator: AddressLike,
      borrower: AddressLike,
      repayAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "liquidateBorrowVerify"
  ): TypedContractMethod<
    [
      tTokenBorrowed: AddressLike,
      tTokenCollateral: AddressLike,
      liquidator: AddressLike,
      borrower: AddressLike,
      repayAmount: BigNumberish,
      seizeTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "liquidateCalculateSeizeTokens"
  ): TypedContractMethod<
    [
      tTokenBorrowed: AddressLike,
      tTokenCollateral: AddressLike,
      repayAmount: BigNumberish
    ],
    [[bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "mintAllowed"
  ): TypedContractMethod<
    [tToken: AddressLike, minter: AddressLike, mintAmount: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "mintVerify"
  ): TypedContractMethod<
    [
      tToken: AddressLike,
      minter: AddressLike,
      mintAmount: BigNumberish,
      mintTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "redeemAllowed"
  ): TypedContractMethod<
    [tToken: AddressLike, redeemer: AddressLike, redeemTokens: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "redeemVerify"
  ): TypedContractMethod<
    [
      tToken: AddressLike,
      redeemer: AddressLike,
      redeemAmount: BigNumberish,
      redeemTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "repayBorrowAllowed"
  ): TypedContractMethod<
    [
      tToken: AddressLike,
      payer: AddressLike,
      borrower: AddressLike,
      repayAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "repayBorrowVerify"
  ): TypedContractMethod<
    [
      tToken: AddressLike,
      payer: AddressLike,
      borrower: AddressLike,
      repayAmount: BigNumberish,
      borrowerIndex: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "seizeAllowed"
  ): TypedContractMethod<
    [
      tTokenCollateral: AddressLike,
      tTokenBorrowed: AddressLike,
      liquidator: AddressLike,
      borrower: AddressLike,
      seizeTokens: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "seizeVerify"
  ): TypedContractMethod<
    [
      tTokenCollateral: AddressLike,
      tTokenBorrowed: AddressLike,
      liquidator: AddressLike,
      borrower: AddressLike,
      seizeTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferAllowed"
  ): TypedContractMethod<
    [
      tToken: AddressLike,
      src: AddressLike,
      dst: AddressLike,
      transferTokens: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferVerify"
  ): TypedContractMethod<
    [
      tToken: AddressLike,
      src: AddressLike,
      dst: AddressLike,
      transferTokens: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  filters: {};
}
